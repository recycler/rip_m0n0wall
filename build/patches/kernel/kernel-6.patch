--- sys/conf/options.orig	Wed Apr 12 20:09:27 2006
+++ sys/conf/options	Sat Nov 18 20:47:01 2006
@@ -352,6 +352,12 @@
 IPFILTER_LOG		opt_ipfilter.h
 IPFILTER_LOOKUP		opt_ipfilter.h
 IPFILTER_DEFAULT_BLOCK	opt_ipfilter.h
+# Existing options made configurable for m0n0wall
+IPSTATE_SIZE		opt_ipfilter.h
+IPSTATE_MAX		opt_ipfilter.h
+# New options for m0n0wall
+IPFILTER_MSSCLAMP_FORCE	opt_ipfilter.h
+# End of m0n0wall additions
 IPFIREWALL		opt_ipfw.h
 IPFIREWALL_VERBOSE	opt_ipfw.h
 IPFIREWALL_VERBOSE_LIMIT	opt_ipfw.h
--- sys/contrib/ipfilter/netinet/fil.c.orig	Thu Jun 23 16:19:02 2005
+++ sys/contrib/ipfilter/netinet/fil.c	Sat Nov 18 20:49:21 2006
@@ -87,6 +87,12 @@
 # include <sys/hashing.h>
 # include <netinet/in_var.h>
 #endif
+#if defined(__FreeBSD_version) && (__FreeBSD_version >= 300000)
+# include <sys/malloc.h>
+# if defined(_KERNEL) && !defined(IPFILTER_LKM)
+#  include "opt_ipfilter.h"
+# endif
+#endif
 #include <netinet/tcp.h>
 #if !defined(__sgi) || defined(_KERNEL)
 # include <netinet/udp.h>
@@ -122,12 +128,6 @@
 #endif
 #if defined(IPFILTER_BPF) && defined(_KERNEL)
 # include <net/bpf.h>
-#endif
-#if defined(__FreeBSD_version) && (__FreeBSD_version >= 300000)
-# include <sys/malloc.h>
-# if defined(_KERNEL) && !defined(IPFILTER_LKM)
-#  include "opt_ipfilter.h"
-# endif
 #endif
 #include "netinet/ipl.h"
 /* END OF INCLUDES */
--- sys/contrib/ipfilter/netinet/mlfk_ipl.c.orig	Mon Apr 25 20:43:14 2005
+++ sys/contrib/ipfilter/netinet/mlfk_ipl.c	Sat Nov 18 20:56:57 2006
@@ -19,6 +19,11 @@
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
 
+#if __FreeBSD_version >= 300000
+# if defined(_KERNEL) && !defined(IPFILTER_LKM)
+#  include "opt_ipfilter.h"
+# endif
+#endif
 
 #include <netinet/ipl.h>
 #include <netinet/ip_compat.h>
--- sys/net/pfil.c.orig	Mon May 23 19:07:16 2005
+++ sys/net/pfil.c	Sat Nov 18 21:05:56 2006
@@ -354,13 +354,15 @@
 		    pfh->pfil_arg == pfh1->pfil_arg)
 			return EEXIST;
 	/*
-	 * insert the input list in reverse order of the output list
-	 * so that the same path is followed in or out of the kernel.
+	 * m0n0wall: insert hooks in reverse order (with respect to default
+	 * FreeBSD behavior) to ensure that the dynamically loaded ipfw
+	 * is called before ipfilter for outbound and after ipfilter for
+	 * inbound packets (due to NAT).
 	 */
 	if (flags & PFIL_IN)
-		TAILQ_INSERT_HEAD(list, pfh1, pfil_link);
-	else
 		TAILQ_INSERT_TAIL(list, pfh1, pfil_link);
+	else
+		TAILQ_INSERT_HEAD(list, pfh1, pfil_link);
 
 	return 0;
 }
--- sys/netgraph/ng_ppp.c.orig	Mon May 16 21:12:57 2005
+++ sys/netgraph/ng_ppp.c	Sat Nov 18 22:06:33 2006
@@ -749,7 +749,11 @@
 	case HOOK_INDEX_VJC_VJIP:
 		if (priv->conf.enableCompression
 		    && priv->hooks[HOOK_INDEX_COMPRESS] != NULL) {
-			if ((m = ng_ppp_addproto(m, proto, 0)) == NULL) {
+			if ((m = ng_ppp_addproto(m, proto,
+			/* Get the PFC enable from the first link (RFC1990) */
+			    priv->links[priv->activeLinks[0]]
+			    .conf.enableProtoComp
+			    )) == NULL) {
 				NGI_M(item) = NULL;
 				NG_FREE_ITEM(item);
 				return (ENOBUFS);
@@ -762,7 +766,11 @@
 	case HOOK_INDEX_COMPRESS:
 		if (priv->conf.enableEncryption
 		    && priv->hooks[HOOK_INDEX_ENCRYPT] != NULL) {
-			if ((m = ng_ppp_addproto(m, proto, 1)) == NULL) {
+			if ((m = ng_ppp_addproto(m, proto,
+			/* Get the PFC enable from the first link (RFC1990) */
+			    priv->links[priv->activeLinks[0]]
+			    .conf.enableProtoComp
+			    )) == NULL) {
 				NGI_M(item) = NULL;
 				NG_FREE_ITEM(item);
 				return (ENOBUFS);
@@ -994,8 +1002,9 @@
 
 	/* Prepend protocol number, possibly compressed */
 	if ((m = ng_ppp_addproto(m, proto,
-	    linkNum == NG_PPP_BUNDLE_LINKNUM
-	      || link->conf.enableProtoComp)) == NULL) {
+	    /* On a bundle, get the PFC enable from the first link (RFC1990) */
+	    (link ? link
+	    : &priv->links[priv->activeLinks[0]])->conf.enableProtoComp)) == NULL) {
 		NG_FREE_ITEM(item);
 		return (ENOBUFS);
 	}
--- sys/netinet/ip_input.c.orig	Sat Mar  4 10:15:08 2006
+++ sys/netinet/ip_input.c	Sat Nov 18 21:09:37 2006
@@ -460,6 +460,8 @@
 	/* Jump over all PFIL processing if hooks are not active. */
 	if (inet_pfil_hook.ph_busy_count == -1)
 		goto passin;
+	if (m->m_flags & M_SKIP_FIREWALL)
+		goto passin;
 
 	odst = ip->ip_dst;
 	if (pfil_run_hooks(&inet_pfil_hook, &m, m->m_pkthdr.rcvif,
--- sys/netinet/ip_dummynet.c.orig	Thu Feb 23 09:28:15 2006
+++ sys/netinet/ip_dummynet.c	Sat Nov 18 21:10:30 2006
@@ -774,6 +774,7 @@
 			ip = mtod(m, struct ip *);
 			ip->ip_len = htons(ip->ip_len);
 			ip->ip_off = htons(ip->ip_off);
+			m->m_flags |= M_SKIP_FIREWALL;
 			ip_input(m);
 			break;
 #ifdef INET6
--- sys/modules/ipfw/Makefile.orig	Sat Feb 11 09:19:37 2006
+++ sys/modules/ipfw/Makefile	Sat Nov 18 21:06:46 2006
@@ -13,8 +13,8 @@
 #CFLAGS+= -DIPFIREWALL_VERBOSE_LIMIT=100
 #
 #If you want it to pass all packets by default
-#CFLAGS+= -DIPFIREWALL_DEFAULT_TO_ACCEPT
-#
+CFLAGS+= -DIPFIREWALL_DEFAULT_TO_ACCEPT
+CFLAGS+= -DIPFIREWALL_FORWARD
 
 .if !defined(KERNBUILDDIR)
 .if !defined(NO_INET6)
--- sys/kern/vfs_mount.c.orig	Mon Mar 13 04:06:27 2006
+++ sys/kern/vfs_mount.c	Sat Nov 18 21:54:28 2006
@@ -1449,7 +1449,7 @@
 		strcpy(path, ROOTNAME);
 
 	error = kernel_vmount(
-	    MNT_RDONLY | MNT_ROOTFS,
+	    MNT_ROOTFS,
 	    "fstype", vfsname,
 	    "fspath", "/",
 	    "from", path,
