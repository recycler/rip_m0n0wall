--- sys/conf/options.orig	2008-02-17 21:32:18.000000000 +0100
+++ sys/conf/options	2008-02-23 19:33:50.000000000 +0100
@@ -362,6 +362,10 @@
 IPFILTER_LOG		opt_ipfilter.h
 IPFILTER_LOOKUP		opt_ipfilter.h
 IPFILTER_DEFAULT_BLOCK	opt_ipfilter.h
+# Existing options made configurable for m0n0wall
+IPSTATE_SIZE           opt_ipfilter.h
+IPSTATE_MAX            opt_ipfilter.h
+# End of m0n0wall additions
 IPFIREWALL		opt_ipfw.h
 IPFIREWALL_VERBOSE	opt_ipfw.h
 IPFIREWALL_VERBOSE_LIMIT	opt_ipfw.h
--- sys/contrib/ipfilter/netinet/fil.c.orig	2007-12-01 01:53:16.000000000 +0100
+++ sys/contrib/ipfilter/netinet/fil.c	2008-02-23 19:34:31.000000000 +0100
@@ -103,6 +103,12 @@
 # include <sys/hashing.h>
 # include <netinet/in_var.h>
 #endif
+#if defined(__FreeBSD_version) && (__FreeBSD_version >= 300000)
+# include <sys/malloc.h>
+# if defined(_KERNEL) && !defined(IPFILTER_LKM)
+#  include "opt_ipfilter.h"
+# endif
+#endif
 #include <netinet/tcp.h>
 #if (!defined(__sgi) && !defined(AIX)) || defined(_KERNEL)
 # include <netinet/udp.h>
@@ -142,12 +148,6 @@
 #if defined(IPFILTER_BPF) && defined(_KERNEL)
 # include <net/bpf.h>
 #endif
-#if defined(__FreeBSD_version) && (__FreeBSD_version >= 300000)
-# include <sys/malloc.h>
-# if defined(_KERNEL) && !defined(IPFILTER_LKM)
-#  include "opt_ipfilter.h"
-# endif
-#endif
 #include "netinet/ipl.h"
 /* END OF INCLUDES */
 
--- sys/contrib/ipfilter/netinet/mlfk_ipl.c.orig	2007-11-18 12:03:29.000000000 +0100
+++ sys/contrib/ipfilter/netinet/mlfk_ipl.c	2008-02-23 19:35:35.000000000 +0100
@@ -23,6 +23,11 @@
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
 
+#if __FreeBSD_version >= 300000
+# if defined(_KERNEL) && !defined(IPFILTER_LKM)
+#  include "opt_ipfilter.h"
+# endif
+#endif
 
 #include <netinet/ipl.h>
 #include <netinet/ip_compat.h>
--- sys/contrib/ipfilter/netinet/ip_state.c.orig	2007-11-18 12:03:29.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_state.c	2008-02-23 19:36:09.000000000 +0100
@@ -150,15 +150,15 @@
 #define	FIVE_DAYS	(5 * ONE_DAY)
 #define	DOUBLE_HASH(x)	(((x) + ips_seed[(x) % fr_statesize]) % fr_statesize)
 
-u_long	fr_tcpidletimeout = FIVE_DAYS,
+u_long	fr_tcpidletimeout = IPF_TTLVAL(9000),
 	fr_tcpclosewait = IPF_TTLVAL(2 * TCP_MSL),
 	fr_tcplastack = IPF_TTLVAL(30),
 	fr_tcptimeout = IPF_TTLVAL(2 * TCP_MSL),
 	fr_tcptimewait = IPF_TTLVAL(2 * TCP_MSL),
 	fr_tcpclosed = IPF_TTLVAL(30),
-	fr_tcphalfclosed = IPF_TTLVAL(2 * 3600),	/* 2 hours */
+	fr_tcphalfclosed = IPF_TTLVAL(240),
 	fr_udptimeout = IPF_TTLVAL(120),
-	fr_udpacktimeout = IPF_TTLVAL(12),
+	fr_udpacktimeout = IPF_TTLVAL(240),
 	fr_icmptimeout = IPF_TTLVAL(60),
 	fr_icmpacktimeout = IPF_TTLVAL(6),
 	fr_iptimeout = IPF_TTLVAL(60);
--- sys/net/pfil.c.orig	2005-05-23 19:07:16.000000000 +0200
+++ sys/net/pfil.c	2008-02-23 19:37:41.000000000 +0100
@@ -354,13 +354,15 @@
 		    pfh->pfil_arg == pfh1->pfil_arg)
 			return EEXIST;
 	/*
-	 * insert the input list in reverse order of the output list
-	 * so that the same path is followed in or out of the kernel.
+	 * m0n0wall: insert hooks in reverse order (with respect to default
+	 * FreeBSD behavior) to ensure that the dynamically loaded ipfw
+	 * is called before ipfilter for outbound and after ipfilter for
+	 * inbound packets (due to NAT).
 	 */
 	if (flags & PFIL_IN)
-		TAILQ_INSERT_HEAD(list, pfh1, pfil_link);
-	else
 		TAILQ_INSERT_TAIL(list, pfh1, pfil_link);
+	else
+		TAILQ_INSERT_HEAD(list, pfh1, pfil_link);
 
 	return 0;
 }
--- sys/netinet/ip_input.c.orig	2007-04-03 10:16:05.000000000 +0200
+++ sys/netinet/ip_input.c	2008-07-09 21:47:45.000000000 +0200
@@ -389,18 +389,22 @@
 		}
 	}

-	if (m->m_pkthdr.csum_flags & CSUM_IP_CHECKED) {
-		sum = !(m->m_pkthdr.csum_flags & CSUM_IP_VALID);
-	} else {
-		if (hlen == sizeof(struct ip)) {
-			sum = in_cksum_hdr(ip);
+	/* skip checksum checks if we came from dummynet, since we'll already
+	   have been here in that case */
+	if (!(m->m_flags & M_IPIN_SKIPPFIL)) {
+		if (m->m_pkthdr.csum_flags & CSUM_IP_CHECKED) {
+			sum = !(m->m_pkthdr.csum_flags & CSUM_IP_VALID);
 		} else {
-			sum = in_cksum(m, hlen);
+			if (hlen == sizeof(struct ip)) {
+				sum = in_cksum_hdr(ip);
+			} else {
+				sum = in_cksum(m, hlen);
+			}
+		}
+		if (sum) {
+			ipstat.ips_badsum++;
+			goto bad;
 		}
-	}
-	if (sum) {
-		ipstat.ips_badsum++;
-		goto bad;
 	}

 #ifdef ALTQ
@@ -463,6 +467,21 @@
 	/* Jump over all PFIL processing if hooks are not active. */
 	if (inet_pfil_hook.ph_busy_count == -1)
 		goto passin;
+	if (m->m_flags & M_IPIN_SKIPPFIL) {
+		/* m0n0wall: packet has already been through dummynet, and therefore
+		   also through ipnat (reversed processing order in m0n0wall);
+		   we skip the pfil hooks to avoid ipnat being called again on
+		   this packet (this implicitly assumes that one_pass=1).
+		   However, we need to remove the dummynet tag, otherwise the
+		   packet will be treated improperly in ip_output. */
+		struct m_tag *dn_tag;
+		dn_tag = m_tag_find(m, PACKET_TAG_DUMMYNET, NULL);
+		if (dn_tag != NULL)
+			m_tag_delete(m, dn_tag);
+		
+		m->m_flags &= ~M_IPIN_SKIPPFIL;
+		goto passin;
+	}

 	odst = ip->ip_dst;
 	if (pfil_run_hooks(&inet_pfil_hook, &m, m->m_pkthdr.rcvif,
--- sys/netinet/ip_dummynet.c.orig	2006-07-29 10:24:12.000000000 +0200
+++ sys/netinet/ip_dummynet.c	2008-02-23 19:42:43.000000000 +0100
@@ -774,6 +774,7 @@
 			ip = mtod(m, struct ip *);
 			ip->ip_len = htons(ip->ip_len);
 			ip->ip_off = htons(ip->ip_off);
+			m->m_flags |= M_IPIN_SKIPPFIL;
 			ip_input(m);
 			break;
 #ifdef INET6
--- sys/modules/ipfw/Makefile.orig	2006-09-19 17:45:21.000000000 +0200
+++ sys/modules/ipfw/Makefile	2008-02-23 19:43:06.000000000 +0100
@@ -13,8 +13,8 @@
 #CFLAGS+= -DIPFIREWALL_VERBOSE_LIMIT=100
 #
 #If you want it to pass all packets by default
-#CFLAGS+= -DIPFIREWALL_DEFAULT_TO_ACCEPT
-#
+CFLAGS+= -DIPFIREWALL_DEFAULT_TO_ACCEPT
+CFLAGS+= -DIPFIREWALL_FORWARD
 
 .if !defined(KERNBUILDDIR)
 .if !defined(NO_INET6)
--- sys/kern/vfs_mount.c.orig	2007-05-10 11:18:07.000000000 +0200
+++ sys/kern/vfs_mount.c	2008-02-23 19:43:42.000000000 +0100
@@ -1602,7 +1602,7 @@
 		strcpy(path, ROOTNAME);
 
 	error = kernel_vmount(
-	    MNT_RDONLY | MNT_ROOTFS,
+	    MNT_ROOTFS,
 	    "fstype", vfsname,
 	    "fspath", "/",
 	    "from", path,
--- sys/sys/mbuf.h.orig	2008-02-17 21:32:18.000000000 +0100
+++ sys/sys/mbuf.h	2008-02-23 19:44:10.000000000 +0100
@@ -179,6 +179,7 @@
 #define	M_FIRSTFRAG	0x1000	/* packet is first fragment */
 #define	M_LASTFRAG	0x2000	/* packet is last fragment */
 #define	M_VLANTAG	0x10000	/* packet has VLAN tag attached */
+#define	M_IPIN_SKIPPFIL	0x20000 /* m0n0wall: skip pfil processing in ip_input */
 
 /*
  * External buffer types: identify ext_buf type.
--- sys/i386/i386/vm_machdep.c.orig	2007-04-30 19:45:44.000000000 +0200
+++ sys/i386/i386/vm_machdep.c	2008-02-23 19:44:49.000000000 +0100
@@ -605,6 +605,12 @@
 		outl(0xcfc, 0xf);
 	}
 
+	if (strcmp(cpu_vendor, "AuthenticAMD") == 0 &&
+	    (cpu_id & 0xfff0) == 0x05a0) {
+		/* PC Engines ALIX reset via CS5536 DIVIL_SOFT_RESET */
+		wrmsr(0x51400017, 1LL);
+	}
+
 #ifdef PC98
 	/*
 	 * Attempt to do a CPU reset via CPU reset port.
--- sys/dev/usb/ehci_pci.c.orig	2007-09-26 19:33:18.000000000 +0200
+++ sys/dev/usb/ehci_pci.c	2008-02-23 19:46:29.000000000 +0100
@@ -95,8 +95,10 @@
 static const char *ehci_device_m5239 = "ALi M5239 USB 2.0 controller";
 
 /* AMD */
-#define PCI_EHCI_DEVICEID_8111		0x10227463
+#define PCI_EHCI_DEVICEID_8111		0x74631022
+#define PCI_EHCI_DEVICEID_CS5536	0x20951022
 static const char *ehci_device_8111 = "AMD 8111 USB 2.0 controller";
+static const char *ehci_device_CS5536 = "AMD CS5536 USB 2.0 controller";
 
 /* ATI */
 #define PCI_EHCI_DEVICEID_SB200		0x43451002
@@ -210,6 +212,8 @@
 		return (ehci_device_m5239);
 	case PCI_EHCI_DEVICEID_8111:
 		return (ehci_device_8111);
+	case PCI_EHCI_DEVICEID_CS5536:
+		return (ehci_device_CS5536);
 	case PCI_EHCI_DEVICEID_SB200:
 		return (ehci_device_sb200);
 	case PCI_EHCI_DEVICEID_SB400:
@@ -421,6 +425,8 @@
 				continue;
 			}
 			bsc = device_get_softc(nbus[0]);
+			if (bsc == 0 || bsc->bdev == 0)
+				continue;
 			free(nbus, M_TEMP);
 			DPRINTF(("ehci_pci_attach: companion %s\n",
 			    USBDEVNAME(bsc->bdev)));
--- sys/contrib/ipfilter/netinet/ip_ftp_pxy.c.orig	2007-11-18 12:03:28.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_ftp_pxy.c	2008-02-23 19:47:00.000000000 +0100
@@ -1114,8 +1114,8 @@
 
 		if (tcp->th_flags & TH_FIN) {
 			if (thseq == f->ftps_seq[1]) {
-				f->ftps_seq[0] = f->ftps_seq[1] - seqoff;
-				f->ftps_seq[1] = thseq + 1 - seqoff;
+				f->ftps_seq[0] = f->ftps_seq[1];
+				f->ftps_seq[1] = thseq + 1;
 			} else {
 				if (ippr_ftp_debug > 1) {
 					printf("FIN: thseq %x seqoff %d ftps_seq %x %x\n",
--- sys/net/bridge.c.orig	2005-08-25 07:01:19.000000000 +0200
+++ sys/net/bridge.c	2008-02-23 19:48:02.000000000 +0100
@@ -1043,8 +1043,7 @@
 	 * NetBSD-style generic packet filter, pfil(9), hooks.
 	 * Enables ipf(8) in bridging.
 	 */
-	if (!IPFW_LOADED) { /* XXX: Prevent ipfw from being run twice. */
-	if (inet_pfil_hook.ph_busy_count >= 0 &&
+	if ((inet_pfil_hook.ph_busy_count >= 0 && bdg_ipf != 0) &&
 	    m0->m_pkthdr.len >= sizeof(struct ip) &&
 	    ntohs(save_eh.ether_type) == ETHERTYPE_IP) {
 	    /*
@@ -1056,12 +1055,24 @@
 	    ip->ip_len = ntohs(ip->ip_len);
 	    ip->ip_off = ntohs(ip->ip_off);
 
+	    /* m0n0wall hack: add M_SKIP_FIREWALL flag to make ipfw ignore this
+	       packet, as we'll call it separately below. Otherwise ipfw would be
+	       run twice, and the original code skips this whole block if
+	       IPFW_LOADED, but that's not an option as it will also skip ipfilter.
+	       Note that this doesn't work for pf as it honors the M_SKIP_FIREWALL
+	       flag as well (ipfilter doesn't), but that doesn't matter in m0n0wall.
+	    */
+	    m0->m_flags |= M_SKIP_FIREWALL;
+
 	    if (pfil_run_hooks(&inet_pfil_hook, &m0, src, PFIL_IN, NULL) != 0) {
 		/* NB: hook should consume packet */
 		return NULL;
 	    }
 	    if (m0 == NULL)			/* consumed by filter */
 		return m0;
+
+	    m0->m_flags &= ~M_SKIP_FIREWALL;
+
 	    /*
 	     * If we get here, the firewall has passed the pkt, but the mbuf
 	     * pointer might have changed. Restore ip and the fields ntohs()'d.
@@ -1070,7 +1081,6 @@
 	    ip->ip_len = htons(ip->ip_len);
 	    ip->ip_off = htons(ip->ip_off);
 	}
-	} /* XXX: Prevent ipfw from being run twice. */
 
 	/*
 	 * Prepare arguments and call the firewall.
--- sys/i386/pci/pci_pir.c.orig	2006-11-20 23:47:00.000000000 +0100
+++ sys/i386/pci/pci_pir.c	2008-02-23 19:50:10.000000000 +0100
@@ -397,12 +397,6 @@
 		pci_pir_dump_links();
 	}
 
-	/* Check for unique IRQ masks. */
-	TAILQ_FOREACH(pci_link, &pci_links, pl_links) {
-		if (pci_link->pl_irqmask != 0 && powerof2(pci_link->pl_irqmask))
-			pci_link->pl_irq = ffs(pci_link->pl_irqmask) - 1;
-	}
-
 	/*
 	 * Check to see if the BIOS has already routed any of the links by
 	 * checking each device connected to each link to see if it has a
@@ -515,15 +509,20 @@
 	}
 
 	/*
-	 * Pick a new interrupt if we don't have one already.  We look for
-	 * an interrupt from several different sets.  First, we check the
-	 * set of PCI only interrupts from the $PIR.  Second, we check the
-	 * set of known-good interrupts that the BIOS has already used.
-	 * Lastly, we check the "all possible valid IRQs" set.
+	 * Pick a new interrupt if we don't have one already.  We look
+	 * for an interrupt from several different sets.  First, if
+	 * this link only has one valid IRQ, use that.  Second, we
+	 * check the set of PCI only interrupts from the $PIR.  Third,
+	 * we check the set of known-good interrupts that the BIOS has
+	 * already used.  Lastly, we check the "all possible valid
+	 * IRQs" set.
 	 */
 	if (!PCI_INTERRUPT_VALID(pci_link->pl_irq)) {
-		irq = pci_pir_choose_irq(pci_link,
-		    pci_route_table->pt_header.ph_pci_irqs);
+		if (pci_link->pl_irqmask != 0 && powerof2(pci_link->pl_irqmask))
+			irq = ffs(pci_link->pl_irqmask) - 1;
+		else
+			irq = pci_pir_choose_irq(pci_link,
+			    pci_route_table->pt_header.ph_pci_irqs);
 		if (!PCI_INTERRUPT_VALID(irq))
 			irq = pci_pir_choose_irq(pci_link, pir_bios_irqs);
 		if (!PCI_INTERRUPT_VALID(irq))
--- sys/contrib/ipfilter/netinet/ip_nat.c.orig	2007-11-18 12:03:28.000000000 +0100
+++ sys/contrib/ipfilter/netinet/ip_nat.c	2008-07-05 10:48:33.000000000 +0200
@@ -3843,7 +3843,7 @@
 					continue;
 			}
 
-			if ((nat = nat_new(fin, np, NULL, nflags,
+			if ((fin->fin_off == 0) && (nat = nat_new(fin, np, NULL, nflags,
 					   NAT_OUTBOUND))) {
 				np->in_hits++;
 				break;
@@ -4137,8 +4137,7 @@
 				}
 			}
 
-			nat = nat_new(fin, np, NULL, nflags, NAT_INBOUND);
-			if (nat != NULL) {
+			if ((fin->fin_off == 0) && (nat = nat_new(fin, np, NULL, nflags, NAT_INBOUND))) {
 				np->in_hits++;
 				break;
 			} else
--- sys/dev/pci/pci.c.orig	2007-08-15 22:56:09.000000000 +0200
+++ sys/dev/pci/pci.c	2008-07-24 21:56:35.000000000 +0200
@@ -1898,7 +1898,9 @@
 	/* ATA devices needs special map treatment */
 	if ((pci_get_class(dev) == PCIC_STORAGE) &&
 	    (pci_get_subclass(dev) == PCIS_STORAGE_IDE) &&
-	    (pci_get_progif(dev) & PCIP_STORAGE_IDE_MASTERDEV))
+	    ((pci_get_progif(dev) & PCIP_STORAGE_IDE_MASTERDEV) ||
+	     (!pci_read_config(dev, PCIR_BAR(0), 4) &&
+	      !pci_read_config(dev, PCIR_BAR(2), 4))) )
 		pci_ata_maps(pcib, bus, dev, b, s, f, rl, force, prefetchmask);
 	else
 		for (i = 0; i < cfg->nummaps;)
